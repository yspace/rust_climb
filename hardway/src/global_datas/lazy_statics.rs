/*

which defines a macro that hides even the lazy initialization, allowing you to write code that looks almost like an ordinary declaration:
 

 An invocation of lazy_static! is just syntax sugar for defining a Lazy value. Under the hood everything works exactly the same as in the example that used once_cell::Lazy (except lazy_static defines its own lazy_static::Lazy). Like with once_cell::Lazy, the actual type of LOG_FILE is not Mutex<String>, but a different type which uses Deref to give out &'static Mutex<String> on method calls. Some details differ, e.g. lazy_static constructs a dummy type also named LOG_FILE and implements Deref on that, while hiding the actual Lazy<T> value in a static variable defined in a function – but the end result is exactly the same.

If you’re curious, you can run cargo expand on code generated by lazy_static! {...} to learn exactly what it does.


 
 */

 use lazy_static::lazy_static;
 use std::sync::Mutex;
 
 lazy_static! {
     static ref LOG_FILE: Mutex<String> = Mutex::new(String::new());
 }
 
 // get_log_file() and set_log_file() defined as with once_cell::Lazy
 
 pub fn get_log_file() -> String {
     LOG_FILE.lock().unwrap().clone()
 }
 
 pub fn set_log_file(file: String) {
     *LOG_FILE.lock().unwrap() = file;
 }

